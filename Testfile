import * as FileUploadModule from "./index";
import { fileUpload } from "./index";

import { useInitialUploadFile } from "utils/hooks/useInitialUploadFile";
import { useUploadFileChunk } from "utils/hooks/useUploadFileChunk";
import { useFinaliseUploadFile } from "utils/hooks/useFinaliseUploadFile";
import { useUploadFile } from "utils/hooks/useUploadFile";

jest.mock("utils/hooks/useInitialUploadFile");
jest.mock("utils/hooks/useUploadFileChunk");
jest.mock("utils/hooks/useFinaliseUploadFile");
jest.mock("utils/hooks/useUploadFile");

describe("fileUpload()", () => {
  let mockInitialUploadFile: jest.Mock;
  let mockUploadFileChunk: jest.Mock;
  let mockFinaliseUploadFile: jest.Mock;
  let mockUploadFile: jest.Mock;

  beforeEach(() => {
    jest.clearAllMocks();

    mockInitialUploadFile = jest.fn();
    mockUploadFileChunk = jest.fn();
    mockFinaliseUploadFile = jest.fn();
    mockUploadFile = jest.fn();

    // ðŸŸ© Correct mock shape for useInitialUploadFile()
    (useInitialUploadFile as jest.Mock).mockReturnValue({
      initialFileUpload: mockInitialUploadFile,
      loading: false,
      error: null,
      data: null,
    });

    // ðŸŸ© Correct mock for useUploadFileChunk()
    (useUploadFileChunk as jest.Mock).mockReturnValue({
      uploadFileChunk: mockUploadFileChunk,
      loading: false,
      error: null,
      data: null,
    });

    // ðŸŸ© Correct mock for useFinaliseUploadFile()
    (useFinaliseUploadFile as jest.Mock).mockReturnValue({
      finaliseUploadFile: mockFinaliseUploadFile,
      loading: false,
      error: null,
      data: null,
    });

    // ðŸŸ© Correct mock for useUploadFile()
    (useUploadFile as jest.Mock).mockReturnValue({
      uploadFile: mockUploadFile,
      loading: false,
      error: null,
      data: null,
    });

    // ðŸŸ© Mock createChunks() â€“ simulating 8MB + partial chunk
    jest.spyOn(FileUploadModule, "createChunks").mockResolvedValue([
      { size: 8 * 1024 * 1024, data: "AAAAA" },
      { size: 4 * 1024 * 1024, data: "BBBBB" },
    ]);

    // ðŸŸ© Mock sha1 for each chunk
    jest
      .spyOn(FileUploadModule, "sha1Base64")
      .mockResolvedValueOnce("digest-1")
      .mockResolvedValueOnce("digest-2");
  });

  test("should upload file chunks, send digest, and finalise upload", async () => {
    mockInitialUploadFile.mockResolvedValue({
      sessionId: "session-123",
    });

    mockUploadFileChunk
      .mockResolvedValueOnce({ partId: 1 })
      .mockResolvedValueOnce({ partId: 2 });

    mockFinaliseUploadFile.mockResolvedValue({
      fileUrl: "https://files.com/output.pdf",
    });

    const mockFileData = {
      file: new File([new Uint8Array(12 * 1024 * 1024)], "bigFile.pdf"),
      fileSize: 12 * 1024 * 1024,
      fileName: "bigFile.pdf",
      fileType: "pdf",
      fileUid: "123",
      description: "",
    };

    const result = await fileUpload(mockFileData);

    // initial upload must be called
    expect(mockInitialUploadFile).toHaveBeenCalledWith({
      fileSize: mockFileData.fileSize,
      fileName: mockFileData.fileName,
    });

    // chunk uploads
    expect(mockUploadFileChunk).toHaveBeenCalledTimes(2);

    expect(mockUploadFileChunk).toHaveBeenCalledWith(
      "session-123",
      expect.objectContaining({
        digest: "digest-1",
        startByte: 0,
        endByte: 8 * 1024 * 1024 - 1,
      })
    );

    expect(mockUploadFileChunk).toHaveBeenCalledWith(
      "session-123",
      expect.objectContaining({
        digest: "digest-2",
        startByte: 8 * 1024 * 1024,
        endByte: 12 * 1024 * 1024 - 1,
      })
    );

    // finalise upload
    expect(mockFinaliseUploadFile).toHaveBeenCalledWith("session-123", {
      parts: [{ partId: 1 }, { partId: 2 }],
    });

    expect(result).toEqual({
      fileUrl: "https://files.com/output.pdf",
    });
  });
});

========
import { fileUpload } from "./fileUpload";
import { createChunks } from "./createChunks";
import { sha1Base64 } from "./sha1Base64";
import { initialFileUpload, uploadFileChunk, finaliseUploadFile } from "./api";

jest.mock("./createChunks");
jest.mock("./sha1Base64");
jest.mock("./api");

describe("fileUpload", () => {
  const mockFileData = {
    fileSize: 20,
    fileName: "test.pdf",
    file: new Blob(["12345678901234567890"]),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("should upload file chunks, send digest, and finalise upload", async () => {
    // mock chunk generation
    (createChunks as jest.Mock).mockResolvedValue([
      { size: 10, data: "chunk1" },
      { size: 10, data: "chunk2" },
    ]);

    // mock sha1 for each chunk
    (sha1Base64 as jest.Mock)
      .mockResolvedValueOnce("digest1")
      .mockResolvedValueOnce("digest2");

    // mock initial upload response
    (initialFileUpload as jest.Mock).mockResolvedValue({
      sessionId: "session123",
    });

    // mock chunk upload responses
    (uploadFileChunk as jest.Mock)
      .mockResolvedValueOnce({ partId: 1 })
      .mockResolvedValueOnce({ partId: 2 });

    // mock final upload
    (finaliseUploadFile as jest.Mock).mockResolvedValue({
      fileUrl: "https://file-url.com/file",
    });

    const result = await fileUpload(mockFileData);

    expect(initialFileUpload).toHaveBeenCalledWith({
      fileName: "test.pdf",
      fileSize: 20,
    });

    expect(createChunks).toHaveBeenCalledWith(mockFileData);
    expect(sha1Base64).toHaveBeenCalledTimes(2);

    // verify each chunk uploaded with digest
    expect(uploadFileChunk).toHaveBeenCalledWith("session123", {
      fileSize: 20,
      chunk: { size: 10, data: "chunk1" },
      startByte: 0,
      endByte: 9,
      digest: "digest1",
    });

    expect(uploadFileChunk).toHaveBeenCalledWith("session123", {
      fileSize: 20,
      chunk: { size: 10, data: "chunk2" },
      startByte: 10,
      endByte: 19,
      digest: "digest2",
    });

    expect(finaliseUploadFile).toHaveBeenCalledWith("session123", {
      parts: [{ partId: 1 }, { partId: 2 }],
    });

    expect(result).toEqual({ fileUrl: "https://file-url.com/file" });
  });
});
----------

import { render, screen, fireEvent, act } from "@testing-library/react";
import FileSetting from "./FileSetting";
import { fileUpload } from "../utils/common/file-upload";
import { uploadRegulatoryFile } from "../services/regulatory";

jest.mock("../utils/common/file-upload");
jest.mock("../services/regulatory");

describe("FileSetting Component - handleUpload", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("should upload file and call uploadRegulatoryFile", async () => {
    // mock fileUpload returning uploadResponse
    (fileUpload as jest.Mock).mockResolvedValue({
      fileUrl: "https://server.com/test.pdf",
      fileName: "test.pdf",
      fileUploadDateTime: "2025-01-01",
    });

    // mock regulatory
    (uploadRegulatoryFile as jest.Mock).mockResolvedValue(true);

    render(<FileSetting />);

    const fileInput = screen.getByTestId("file-input");

    const fakeFile = new File(["hello"], "test.pdf", { type: "application/pdf" });

    await act(async () => {
      fireEvent.change(fileInput, { target: { files: [fakeFile] } });
    });

    expect(fileUpload).toHaveBeenCalled();
    expect(uploadRegulatoryFile).toHaveBeenCalledWith(
      {
        fileUrl: "https://server.com/test.pdf",
        fileName: "test.pdf",
        fileUploadDateTime: "2025-01-01",
      },
      expect.any(String) // description
    );
  });

  test("should show error message when upload fails", async () => {
    (fileUpload as jest.Mock).mockRejectedValue(new Error("Upload failed"));

    render(<FileSetting />);

    const fileInput = screen.getByTestId("file-input");
    const fakeFile = new File(["hello"], "test.pdf");

    await act(async () => {
      fireEvent.change(fileInput, { target: { files: [fakeFile] } });
    });

    expect(await screen.findByText("File not uploaded")).toBeInTheDocument();
  });
});
