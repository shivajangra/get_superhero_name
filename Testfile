
function mockCryptoSHA1() {
  const crypto = require("crypto");

  global.crypto = {
    subtle: {
      digest: (_alg: string, data: ArrayBuffer) => {
        const nodeHash = crypto.createHash("sha1");
        nodeHash.update(Buffer.from(data));
        const digest = nodeHash.digest();

        return Promise.resolve(
          new Uint8Array(digest).buffer  // ArrayBuffer
        );
      }
    }
  } as any;
}

describe("sha1Base64", () => {
  beforeAll(() => mockCryptoSHA1());

  it("should return correct SHA1 base64 hash", async () => {
    const blob = new Blob(["hello world"]);

    const result = await sha1Base64(blob);

    expect(result).toBe("Kq5sNclPz7QV2+lfQIuc6R7oRu0=");
  });
});



function isEqual(a, b) {
  if (a === b) return true;
  if (typeof a !== typeof b) return false;
  if (typeof a !== "object" || a === null || b === null) return false;

  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    return a.every((item, i) => isEqual(item, b[i]));
  }

  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;

  return keysA.every(key => isEqual(a[key], b[key]));
}

// Get updated objects
function getUpdatedObjects(original, updated) {
  return updated.filter(updatedObj => {
    const originalObj = original.find(o => o.id === updatedObj.id);
    if (!originalObj) return false;

    return !isEqual(updatedObj, originalObj);
  });
}

const changedObjects = getUpdatedObjects(originalData, updatedData);

console.log(changedObjects)

import { isEqual, getUpdatedObjects } from './deepCompare'; // adjust path as needed

describe('isEqual()', () => {
  test('returns true for identical primitive values', () => {
    expect(isEqual(5, 5)).toBe(true);
    expect(isEqual('abc', 'abc')).toBe(true);
  });

  test('returns false for different primitive values', () => {
    expect(isEqual(5, 10)).toBe(false);
    expect(isEqual('abc', 'def')).toBe(false);
  });

  test('returns true for identical shallow objects', () => {
    const a = { x: 1, y: 2 };
    const b = { x: 1, y: 2 };
    expect(isEqual(a, b)).toBe(true);
  });

  test('returns false for shallow objects with different values', () => {
    const a = { x: 1, y: 2 };
    const b = { x: 1, y: 3 };
    expect(isEqual(a, b)).toBe(false);
  });

  test('returns true for deeply nested objects', () => {
    const a = { x: { y: { z: [1, 2, 3] } } };
    const b = { x: { y: { z: [1, 2, 3] } } };
    expect(isEqual(a, b)).toBe(true);
  });

  test('returns false for deeply nested objects with different values', () => {
    const a = { x: { y: { z: [1, 2, 3] } } };
    const b = { x: { y: { z: [1, 2, 4] } } };
    expect(isEqual(a, b)).toBe(false);
  });

  test('returns false for arrays of different lengths', () => {
    const a = [1, 2];
    const b = [1, 2, 3];
    expect(isEqual(a, b)).toBe(false);
  });

  test('returns true for arrays of identical objects', () => {
    const a = [{ id: 1, val: 'a' }, { id: 2, val: 'b' }];
    const b = [{ id: 1, val: 'a' }, { id: 2, val: 'b' }];
    expect(isEqual(a, b)).toBe(true);
  });

  test('returns false for arrays of objects with different nested values', () => {
    const a = [{ id: 1, val: 'a' }];
    const b = [{ id: 1, val: 'b' }];
    expect(isEqual(a, b)).toBe(false);
  });
});

describe('getUpdatedObjects()', () => {
  const original = [
    {
      id: 1,
      name: 'Alice',
      details: { age: 25, skills: [{ name: 'JS' }] }
    },
    {
      id: 2,
      name: 'Bob',
      details: { age: 30, skills: [{ name: 'Python' }] }
    }
  ];

  const updated = [
    {
      id: 1,
      name: 'Alice',
      details: { age: 26, skills: [{ name: 'JS' }] } // age changed
    },
    {
      id: 2,
      name: 'Bob',
      details: { age: 30, skills: [{ name: 'Python' }, { name: 'Django' }] } // added skill
    },
    {
      id: 3,
      name: 'Charlie',
      details: { age: 20, skills: [] } // new record (ignored)
    }
  ];

  test('returns only objects with updated properties', () => {
    const result = getUpdatedObjects(original, updated);
    expect(result).toHaveLength(2);
    expect(result.map(r => r.id)).toEqual([1, 2]);
  });

  test('returns empty array if nothing changed', () => {
    const same = JSON.parse(JSON.stringify(original));
    expect(getUpdatedObjects(original, same)).toHaveLength(0);
  });

  test('ignores new objects that donâ€™t exist in original array', () => {
    const result = getUpdatedObjects(original, updated);
    expect(result.find(r => r.id === 3)).toBeUndefined();
  });
});
