
// Minimal SHA-1 implementation (tiny version)
export async function sha1Mini(blob: Blob): Promise<string> {
  const buffer = await blob.arrayBuffer();
  const bytes = new Uint8Array(buffer);

  function rotl(n: number, s: number) {
    return (n << s) | (n >>> (32 - s));
  }

  function toHex(i: number) {
    return ('00000000' + i.toString(16)).slice(-8);
  }

  // Convert bytes to 32-bit words
  const words = [];
  for (let i = 0; i < bytes.length; i += 4) {
    words[i >> 2] =
      (bytes[i] << 24) |
      (bytes[i + 1] << 16) |
      (bytes[i + 2] << 8) |
      (bytes[i + 3] || 0);
  }

  // Append padding
  const bitLen = bytes.length * 8;
  words[bitLen >> 5] |= 0x80 << (24 - (bitLen % 32));
  words[((bitLen + 64 >> 9) << 4) + 15] = bitLen;

  // SHA-1 initial constants
  let h0 = 0x67452301;
  let h1 = 0xefcdab89;
  let h2 = 0x98badcfe;
  let h3 = 0x10325476;
  let h4 = 0xc3d2e1f0;

  const w = new Array(80);

  // Process blocks
  for (let i = 0; i < words.length; i += 16) {
    for (let t = 0; t < 80; t++) {
      w[t] =
        t < 16
          ? words[i + t]
          : rotl(w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16], 1);
    }

    let a = h0, b = h1, c = h2, d = h3, e = h4;

    for (let t = 0; t < 80; t++) {
      const f =
        t < 20
          ? (b & c) | (~b & d)
          : t < 40
          ? b ^ c ^ d
          : t < 60
          ? (b & c) | (b & d) | (c & d)
          : b ^ c ^ d;

      const k =
        t < 20
          ? 0x5a827999
          : t < 40
          ? 0x6ed9eba1
          : t < 60
          ? 0x8f1bbcdc
          : 0xca62c1d6;

      const temp = (rotl(a, 5) + f + e + k + w[t]) >>> 0;
      e = d;
      d = c;
      c = rotl(b, 30);
      b = a;
      a = temp;
    }

    h0 = (h0 + a) >>> 0;
    h1 = (h1 + b) >>> 0;
    h2 = (h2 + c) >>> 0;
    h3 = (h3 + d) >>> 0;
    h4 = (h4 + e) >>> 0;
  }

  return (
    toHex(h0) +
    toHex(h1) +
    toHex(h2) +
    toHex(h3) +
    toHex(h4)
  );
}
